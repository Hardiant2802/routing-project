####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
import json
import heapq
from packet import Packet


class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.topology = {self.addr: {}}
        self.seq_nums = {self.addr: 0}
        self.neighbors = {}
        self.forwarding_table = {}

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            dst = packet.dst_addr
            if dst in self.forwarding_table:
                out_port = self.forwarding_table[dst]
                self.send(out_port, packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            data = json.loads(packet.content)
            src = data["src"]
            seq = data["seq"]
            links = data["links"]

            if src not in self.seq_nums or seq > self.seq_nums[src]:
                self.seq_nums[src] = seq
                self.topology[src] = links
                self.compute_paths()

                for neighbor, (p, _) in self.neighbors.items():
                    if p != port:
                        new_packet = Packet(Packet.ROUTING, self.addr, neighbor, packet.content)
                        self.send(p, new_packet)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.neighbors[endpoint] = (port, cost)
        self.topology[self.addr][endpoint] = cost
        self.seq_nums[self.addr] += 1
        self.broadcast_link_state()
        self.compute_paths()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        endpoint = None
        for neighbor, (p, _) in self.neighbors.items():
            if p == port:
                endpoint = neighbor
                break

        if endpoint:
            del self.neighbors[endpoint]
            if endpoint in self.topology[self.addr]:
                del self.topology[self.addr][endpoint]
            self.seq_nums[self.addr] += 1
            self.broadcast_link_state()
            self.compute_paths()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.broadcast_link_state()

    def broadcast_link_state(self):
        """Gửi thông tin link state của router này đến tất cả hàng xóm."""
        links = {n: c for n, (_, c) in self.neighbors.items()}
        content = json.dumps({
            "src": self.addr,
            "seq": self.seq_nums[self.addr],
            "links": links
        })
        for neighbor, (port, _) in self.neighbors.items():
            packet = Packet(Packet.ROUTING, self.addr, neighbor, content)
            self.send(port, packet)

    def compute_paths(self):
        dist = {self.addr: 0}
        prev = {self.addr: None}
        visited = set()
        heap = [(0, self.addr)]

        while heap:
            cost, node = heapq.heappop(heap)
            if node in visited:
                continue
            visited.add(node)

            if node not in self.topology:
                continue

            for neighbor, link_cost in self.topology[node].items():
                new_cost = cost + link_cost
                if neighbor not in dist or new_cost < dist[neighbor]:
                    dist[neighbor] = new_cost
                    prev[neighbor] = node
                    heapq.heappush(heap, (new_cost, neighbor))

        # Xây bảng định tuyến mới
        new_forwarding = {}
        for dest in dist:
            if dest == self.addr:
                continue

            # Tìm next hop từ this router đến destination
            path = []
            current = dest
        
        # Xây dựng ngược đường đi từ dest về this router
            while current is not None:
                path.append(current)
                current = prev.get(current)
        
        # Nếu không có đường đi
            if not path or path[-1] != self.addr:
                continue
            
            next_hop = path[-2] 
        
            if next_hop in self.neighbors:
                port = self.neighbors[next_hop][0]
                new_forwarding[dest] = port

        self.forwarding_table = new_forwarding

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"